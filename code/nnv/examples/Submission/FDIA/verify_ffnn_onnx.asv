%% Robustness verification of FFNN against FDIAs
%
% Necessary updates
% - adjust everything for multiple epsilons.
% - adjust results to how you want them recorded
% - adjust everything for multiple models
%

% Suppress warnings
warning('off', 'nnet_cnn_onnx:onnx:WarnAPIDeprecation');
warning('off', 'nnet_cnn_onnx:onnx:FillingInClassNames');

%% Load data into NNV
warning('on', 'verbose')

% Specify the ONNX files to load

% 50_100_50 model -> onnx model 1
onnx_model_1 = fullfile('fdia_at/fdia_model_ffnn_pytorch_50_100_50.onnx');

% 100_200_100 model -> onnx model 2
onnx_model_2 = fullfile('fdia_at/fdia_model_ffnn_pytorch_100_200_100.onnx');

% 200_400_200 model -> onnx model 3
onnx_model_3 = fullfile('fdia_at/fdia_model_ffnn_pytorch_200_400_200.onnx');

% Iterate through each of the ONNX files
for j=1:3
    disp("-------- RUNNING ONNX MODEL "+string(j)+" --------")
    % Load the ONNX file as DAGNetwork
    if j == 1
        netONNX = importONNXNetwork(onnx_model_1, 'OutputLayerType', 'classification', 'InputDataFormats', {'BC'});
    elseif j == 2
        netONNX = importONNXNetwork(onnx_model_2, 'OutputLayerType', 'classification', 'InputDataFormats', {'BC'});
    else
        netONNX = importONNXNetwork(onnx_model_3, 'OutputLayerType', 'classification', 'InputDataFormats', {'BC'});
    end

    % Convert the DAGNetwork to NNV format
    net = matlab2nnv(netONNX);
     
    % Jimmy Rigged Fix: manually edit ouput size
    net.OutputSize = 2;
    
    % Load data
    load('test_data_01.mat', 'X', 'y');
    X_test_loaded = permute(X, [2, 1]); % change this for matlab expected format
    y_test_loaded = y+1;  % update labels
    
    % Normalize features in X_test_loaded
    min_values = min(X_test_loaded, [], 2);
    max_values = max(X_test_loaded, [], 2);
    
    % Ensure no division by zero for constant features
    variableFeatures = max_values - min_values > 0;
    min_values(~variableFeatures) = 0; % Avoids changing constant features
    max_values(~variableFeatures) = 1; % Avoids division by zero
    
    % Count total observations
    total_obs = size(X_test_loaded, 2);
    % Make sure numObs is divisible by 2.
    numObs = 100;
    
    %%
    % Test accuracy --> verify matches with python
    %
    % total_corr = 0;
    % for i=1:total_obs
    %     im = X_test_loaded(:, i);
    %     predictedLabels = net.evaluate(im);
    %     [~, Pred] = max(predictedLabels);
    %     TrueLabel = y_test_loaded(i);
    %     if Pred == TrueLabel
    %         total_corr = total_corr + 1;
    %     end
    % end
    % disp(total_corr/total_obs);
    
    %% Main Computation

    % to save results (robustness and time)
    results = zeros(numObs,2);
    
    % Define reachability method
    reachOptions.reachMethod = 'relax-star-area';
    reachOptions.relaxFactor = 0.5;
    
    nR = 67; % ---> just chosen arbitrarily
    
    % ADJUST epsilon value here
    epsilon = [0.001,0.01,0.25];
    
    % Set up results
    nE = 1; %% will need to update later
    res = zeros(numObs,nE); 
    time = zeros(numObs,nE); 
    met = repmat("relax", [numObs, nE]);
    
    % Find the indices for target values 1 and 0 (attack and normal data)
    idx_target_1 = find(y == 1);
    idx_target_2 = find(y == 0);
    
    % Determine the number of observations to sample for each target value
    num_observations_target_1 = min(floor(numObs / 2), length(idx_target_1));
    num_observations_target_2 = min(floor(numObs / 2), length(idx_target_2));
    
    % Randomly select the observations for each target value
    rand_indices_1 = randsample(idx_target_1, num_observations_target_1);
    rand_indices_2 = randsample(idx_target_2, num_observations_target_2);
    
    % Combine the selected indices
    rand_indices = [rand_indices_1, rand_indices_2];
    
    % Shuffle the indices
    rand_indices = rand_indices(randperm(length(rand_indices)));
    
    % Iterate through different epsilon values
    for e=1:length(epsilon) 

        % Iterate through specified observations
        for i=1:numObs
            idx = rand_indices(i);
            [IS, xRand] = L_inf_attack(X_test_loaded(:, idx), epsilon(e), nR, min_values, max_values);
             %
             % Try falsification, then relax star, if unknown, try approx-star
             %
             t = tic;
             for xR=1:length(nR+3)
                im = xRand(:, xR);
                predictedLabels = net.evaluate(im);
                [~, Pred] = max(predictedLabels);
                if Pred == y_test_loaded(idx) % the current label of the orignal image
                    res(i,e) = 0; % counterexample found
                    time(i,e) = toc(t);
                    met(i,e) = "counterexample";
                    continue;
                end
             end
        
             try
                % relax star
                temp = net.verify_robustness(IS,reachOptions,y_test_loaded(idx));
                % approx reachability if relax star unknown
                if temp ~= 1 && temp ~= 0
                    reachOptions = struct;
                    reachOptions.reachMethod = 'approx-star';
                    temp = net.verify_robustness(IS,reachOptions,y_test_loaded(idx));
                    met(i,e) = 'approx';
                end
              catch ME
                met(i,e) = ME.message;
                temp = -1;
             end
              res(i,e) = temp; % robust result
              time(i, e) = toc(t); % store computation time
        
                   
              % reset reachOptions
              reachOptions.reachMethod = 'relax-star-area';
              reachOptions.relaxFactor = 0.5;
        end
    
    % Get summary results
    N = numObs;
    rob = sum(res(:,e)==1);
    not_rob = sum(res(:,e) == 0);
    unk = sum(res(:,e) == 2);
    totalTime = sum(time(:,e));
    avgTime = totalTime/N;
    
    % Print results to screen
    disp("======= ROBUSTNESS RESULTS e: "+string(epsilon(e))+" ==========")
    disp(" ");
    disp("Number of robust samples = "+string(rob)+ ", equivalent to " + string(100*rob/N) + "% of the samples.");
    disp("Number of not robust samples = " +string(not_rob)+ ", equivalent to " + string(100*not_rob/N) + "% of the samples.")
    disp("Number of unknown samples = "+string(unk)+ ", equivalent to " + string(100*unk/N) + "% of the samples.");
    disp(" ");
    disp("It took a total of "+string(totalTime) + " seconds to compute the verification results, an average of "+string(avgTime)+" seconds per sample");
    
    save("robustness_results_ex1","res","time","epsilon","met");
    end
end

% Notify me via slack the verification has finished
webhookUrl = 'https://hooks.slack.com/services/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';
message = struct('text', 'FDIA computation complete!');

options = weboptions('MediaType', 'application/json');
response = webwrite(webhookUrl, message, options);

disp('Message sent to Slack.');

 
%% Helper Function
function [IS, xRand] = L_inf_attack(x, epsilon, nR, min_values, max_values)
    % Apply a L-infinity attack of value epsilon on selected features of input image x
    % where VariableFeatures is true.
    % Return an ImageStar (IS) and random images from initial set
    SampleSize = size(x);

    % Define the rows to exclude from perturbation
    row_indices_to_exclude = [28, 57, 86, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127];

    % Create a logical index to select the rows that should be perturbed
    row_indices_to_perturb = true(SampleSize(1), 1);
    row_indices_to_perturb(row_indices_to_exclude) = false;

    % Initialize disturbance to affect all rows except the specified ones
    disturbance = zeros(SampleSize, "like", x);
    disturbance(row_indices_to_perturb, :) = epsilon;

    % Calculate disturbed lower and upper bounds considering min and max values
    lb = max(x - disturbance, min_values);
    ub = min(x + disturbance, max_values);

    IS = ImageStar(single(lb), single(ub)); % default: single (assume onnx input models)

    % Create random images from initial set
    % Adjusted reshaping according to your specific needs
    lb = reshape(lb, [128,1]);  % Update the reshape parameters as per your actual data dimension
    ub = reshape(ub, [128,1]);
    xB = Box(single(lb), single(ub));
    xRand = xB.sample(nR);
    xRand = reshape(xRand,[128,nR]);
    xRand(:,nR+1) = x; % add original image
    xRand(:,nR+2) = IS.im_lb; % add lower bound image
    xRand(:,nR+3) = IS.im_ub; % add upper bound image

end